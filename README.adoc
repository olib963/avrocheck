= Avrocheck

--
image::https://circleci.com/gh/olib963/avrocheck.svg?style=svg[link="https://circleci.com/gh/olib963/avrocheck", float="left"]
image::https://img.shields.io/maven-central/v/io.github.olib963/avrocheck.svg?style=plastic[link="http://mvnrepository.com/artifact/io.github.olib963/avrocheck", float="left"]
--

Small library to generate random ``GenericRecord``s from a given https://avro.apache.org/[Avro] schema using https://www.scalacheck.org/[ScalaCheck].

== Why?

First of all we always want to make sure that our custom deserialisation code is able to deserialise any message
using it's reader schema that was written using the _writer schema_.

Example schema:

.UserSchema.avsc
[source, json]
----
{
  "namespace": "example.avro",
  "type": "record",
  "name": "User",
  "fields": [
    {
      "name": "name",
      "type": "string"
    },
    {
      "name": "age",
      "type": "int"
    },
    {
      "name": "favourite_number",
      "type": [
        "int",
        "null"
      ]
    }
  ]
}
----

An example test to check this using https://github.com/sksamuel/avro4s[avro4s] would be something like:

.User.scala
[source, scala]
----
import com.sksamuel.avro4s.{AvroName, AvroSchema, Decoder}
import org.apache.avro.Schema

case class User(name: String, @AvroName("favourite_number") favouriteNumber: Option[Int])

object User {
  val decoder: Decoder[User] = Decoder[User]
  val schema: Schema = AvroSchema[User]
}
----

.SerdeProperty.scala
[source, scala]
----
import com.sksamuel.avro4s.DefaultFieldMapper
import org.scalacheck.{Arbitrary, Properties}
import org.scalacheck.Prop.forAll
import io.github.olib963.avrocheck._
import io.github.olib963.avrocheck.Implicits._

import scala.util.{Success, Try}

object SerdeProperty extends Properties("Serde") {

  val schema = schemaFromResource("user-schema.avsc")

  property("deserialises user messages") = forAll(genFromSchema(schema)) { record =>
    Try(User.decoder.decode(record, User.schema, DefaultFieldMapper)).isSuccess
  }

  // Or if you want to be more precise:
  property("deserialises user messages with correct values") = {
    val generator = for {
      name <- Arbitrary.arbString.arbitrary
      favNum <- Arbitrary.arbOption[Int].arbitrary
      favourite_number = favNum.map(Int.box).orNull

      // Notice that here we do not override age (or in the later schema favourite_colour) because these
      // values are of no interest to our application code
      overrides = overrideKeys("name" -> name, "favourite_number" -> favourite_number)
      record <- genFromSchema(schema, overrides = overrides)
    } yield (record, User(name, favNum))
    forAll(generator) { case (record, user) =>
      Try(User.decoder.decode(record, User.schema, DefaultFieldMapper)) == Success(user)
    }
  }

}
----

Secondly it can be useful to write high level system property tests in terms of messages in and out. As an
example we will use the above schema to write a very simple application that signs up users with their favourite number.
If their favourite number is negative we give them a Â£10 sign up bonus and if it is between -1000 and -2000 we give them double.

[source, scala]
----
import io.github.olib963.avrocheck._
import io.github.olib963.avrocheck.Implicits._
import org.apache.avro.Schema
import org.scalacheck.Prop.forAll
import org.scalacheck.{Gen, Properties}

import scala.util.Success

object ApplicationProperty extends Properties("My application") {

  val schema = schemaFromResource("user-schema.avsc")

  property("persists users with negative favourite numbers and gives them a bonus") = {
    val generator = for {
      name <- Gen.alphaNumStr
      // Any number in (-inf, -2001] or [-1000, -1]
      favNum <- Gen.oneOf(Gen.negNum[Int].map(_ - 2001), Gen.chooseNum[Int](-1000, -1))
      overrides = overrideKeys("name" -> name, "favourite_number" -> favNum)
      message <- genFromSchema(schema, overrides = overrides)
    } yield (name, message)
    forAll(generator) { case (name, message) =>
      val result = Application.processUser(message)
      result == Success(PersistedWithBonus(name, 10))
    }
  }

  property("gives a double bonus if their favourite number is between -2000 and -1000") = {
    val generator = for {
      name <- Gen.alphaNumStr
      favNum <- Gen.chooseNum[Int](-2000, -1001)
      overrides = overrideKeys("name" -> name, "favourite_number" -> favNum)
      message <- genFromSchema(schema, overrides = overrides)
    } yield (name, message)
    forAll(generator) { case (name, message) =>
      val result = Application.processUser(message)
      result == Success(PersistedWithBonus(name, 20))
    }
  }

  property("persists users with a positive or no favourite number with no bonus") = {
    val generator = for {
      name <- Gen.alphaNumStr
      favNum <- Gen.oneOf(Gen.const(null), Gen.posNum[Int])
      overrides = overrideKeys("name" -> name, "favourite_number" -> favNum)
      message <- genFromSchema(schema, overrides = overrides)
    } yield (name, message)
    forAll(generator) { case (name, message) =>
      val result = Application.processUser(message)
      result == Success(Persisted(name))
    }
  }

}
----

Due to the compatability features of avro, producers upstream of you should be able to make backwards
compatible changes without affecting your codebase. It is easy now to verify this by just updating the schema file. For example
by adding the following:

[source, json]
----
{
  "name": "favourite_colour",
  "type": [
    "string",
    "null"
  ],
  "deafult": "null"
}
----

to the above schema, the example tests all still pass.

== How?

Simply extend the `AvroCheck` trait and provide it a schema, there is a utility function to read
schemas from a resource file. The schema must either be for a `RECORD` or a `UNION` of ``RECORD``s.

[source, scala]
----
import org.apache.avro.generic.GenericRecord
import org.scalatest.prop.PropertyChecks
import org.scalacheck.Gen
import io.github.olib963.avrocheck.AvroCheck

class MyTest extends PropertyChecks with AvroCheck {
  private val mySchema = schemaFromResource("my-schema.avsc")
  private val gen: Gen[GenericRecord] = genFromSchema(mySchema)

  forAll(gen) { record: GenericRecord =>
     // Stuff with record
  }
}
----

To change the default generators used for the underlying values you can provide an implicit `Arbitrary`.

[source, scala]
----
import io.github.olib963.avrocheck.AvroCheck
import org.scalacheck.{Arbitrary, Gen}

class MyTest extends AvroCheck {
  // Only use positive integers and alpha strings, all other generators remain the same.
  implicit val positiveInts: Arbitrary[Int] = Arbitrary(Gen.posNum[Int])
  implicit val alphaOnly: Arbitrary[String] = Arbitrary(Gen.alphaStr)

}
----

=== Overrides

If you want to customise the generation of your `GenericRecord` even more you can provide an implicit `Overrides` object.

[source, scala]
----
implicit val overrides: Overrides = selectUnion("Bar")
val gen = genFromSchema(schema)
----

=== Logical Types

Logical types will automatically be generated using the types:

* `timestamp-millis` -> `java.time.Instant`
* `timestamp-micros` -> `java.time.Instant`
* `time-millis` -> `java.time.LocalTime`
* `time-micros` -> `java.time.LocalTime`
* `date` -> `java.time.LocalDate`
* `uuid` -> `java.util.UUID`
* `decimal` -> `scala.math.BigDecimal`

If you want to provide overrides or implicit `Arbitrary`s for logical types you must use these types e.g.

[source, scala]
----
// This will not work
implicit val onlyDaysSinceEpoch: Arbitrary[Int] = Arbitrary(gen.posNum[Int])


// This will work
implicit val onlyDaysSinceEpoch: Arbitrary[LocalDate] =
    Arbitrary(gen.posNum[Int].map(LocalDate.ofEpochDay)
----

If you don't want to go through the hassle of adding logical type conversions to your serialiser you can
set the option `preserialiseLogicalTypes` to `true` and the values will automatically be turned into their underlying primitives.
 You must however still use the correct arbitrary e.g.

[source, scala]
----
implicit val onlyDaysSinceEpoch: Arbitrary[LocalDate] =
       Arbitrary(gen.posNum[Int].map(LocalDate.ofEpochDay)

val schema = schemaFromResource("my-schema-with-date-type.avsc")
val generator = genFromSchema(schema, preserialiseLogicalTypes = true)

forAll(generator)(record => record.get("dateField") isInstanceOf[Int] )
----


== Confluent Stack Warning

If you are using this library to run integration tests that integrate with Kafka and the confluent stack you should be aware
of this:

=== Schema Registry with Unions

If you are generating messages that are a `UNION` of ``RECORD``s at the top level and you are using schema registry
you will want the union schema to be posted for your topic. This means you _cannot_ simply serialise the `GenericRecord`,
instead you will need to do this:

[source, scala]
----
import org.apache.avro.generic.GenericRecord
import org.scalacheck.Gen
import io.github.olib963.avrocheck.AvroCheck

class MyTest extends AvroCheck {

  // Schema of two records named "Foo" and "Bar"
  private val unionSchema = schemaFromResource("my-union-schema.avsc")
  private val gen: Gen[GenericRecord] = genFromSchema(unionSchema)

  def serialise() {
    val genericRecord = gen.sample.get
    val serialiser = new KafkaAvroSerialiser(new MySchemaRegistryClient())

    // This is NOT what you want, this will post the schema for "Foo" or "Bar" only, not the union of both
    serialiser.serialise("my-topic", genericRecord)

    // This is what you want, this will post the union schema for the topic and serialise the
    // genericRecord using "Foo" or "Bar" respectively
    serialiser.serialise("my-topic", new NonRecordContainer(unionSchema, genericRecord))
  }
}
----